# 선택 정렬

- 가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘입니다.
- 시간 복잡도 O(N^2)
    - 만약 정렬해야 할 데이터 수가 10,000개라면 일 억 번을 계산해야 합니다.

```c
#include <stdio.h>

int main(void) {
    int i, j, min, index, temp; 
    int array[10] = {11, 10, 5, 8, 7, 6, 4, 3, 2, 9};

    for (i = 0; i < 10; i++) {
        min = 9999;     // 현재 최소값을 매우 큰 수로 초기화
        index = i;      // 현재 위치를 최소 인덱스로 가정

        for (j = i; j < 10; j++) {  // i부터 끝까지 비교
            if (min > array[j]) {  // 더 작은 값을 찾으면
                min = array[j];
                index = j;         // 해당 인덱스를 기억
            }
        }

        // 최소값과 현재 위치 i의 값 교환
        temp = array[i];
        array[i] = array[index];
        array[index] = temp;
    }

    for (i = 0; i < 10; i++) {
        printf("%d ", array[i]);
    }

    return 0;
}

```

# 버블 정렬

- 옆에 있는 값과 비교해서 더 작은 값은 반복적으로 앞으로 보내는 알고리즘 입니다.
- 구현은 쉽지만 가장 비효율적입니다.
- 시간 복잡도 O(N^2)

```c
#include <stdio.h>

int main(void) {
    int i, j, temp;  
    int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};  

    for (i = 0; i < 10; i++) {         
        for (j = 0; j < 9 - i; j++) {    // 이미 정렬된 마지막 부분은 제외
            if (array[j] > array[j + 1]) {
                // 인접한 두 수가 크기 순서가 잘못돼 있으면 교환
                temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
            }
        }
    }

    for (i = 0; i < 10; i++) {
        printf("%d ", array[i]);
    }

    return 0;
}

```

# 삽입 정렬

- 각 숫자를 적절한 위치에 삽이하는 알고리즘입니다.
- 어느 정도 정렬이 되어있는 경우 속도가 빠르다는 특징이 있습니다.
- 시간 복잡도 O(N^2)

```c
#include <stdio.h>

int main(void) {
    int i, j, temp;  
    int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};  

    // 삽입 정렬 시작
    for (i = 0; i < 9; i++) { 
        j = i;
        
        // 앞쪽 원소들과 비교하며 올바른 위치에 삽입
        while (j >= 0 && array[j] > array[j + 1]) {
            // 현재 값이 다음 값보다 크면 교환 (오름차순 정렬)
            temp = array[j];
            array[j] = array[j + 1];
            array[j + 1] = temp;
            j--; // 왼쪽으로 한 칸 이동하여 다시 비교
        }
    }

    for (i = 0; i < 10; i++) {
        printf("%d ", array[i]);
    }
    
    return 0;
}

```

# 퀵 정렬

- 대표적인 빠른 정렬 알고리즘
- 분할 정복 알고리즘
- 피벗을 기준으로 반을 나눠 작게 쪼갠 뒤
- 시간 복잡도
    - 평균 O(N * logN)
    - 최악(이미 정렬이 되어 있는 경우) O(N^2)

![image.png](./assets/퀵정렬.png)

```c
#include <stdio.h>

int number = 10;
int data[] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};

void show() {
    int i;
    for (i = 0; i < number; i++) {
        printf("%d ", data[i]);
    }
}

void quickSort(int* data, int start, int end) {
    if (start >= end) return;  // 원소가 1개인 경우 그대로 두기

    int key = start;           // 키는 첫 번째 원소
    int i = start + 1;
    int j = end;
    int temp;

    while (i <= j) {  // 엇갈릴 때까지 반복
        while (i <= end && data[i] <= data[key]) {
            i++;  // 키 값보다 큰 값 찾을 때까지
        }
        while (j > start && data[j] >= data[key]) {
            j--;  // 키 값보다 작은 값 찾을 때까지
        }

        if (i > j) {  // 엇갈린 경우: 키 값과 data[j] 교환
            temp = data[j];
            data[j] = data[key];
            data[key] = temp;
        } else {      // 엇갈리지 않았으면 i, j 교환
            temp = data[i];
            data[i] = data[j];
            data[j] = temp;
        }
    }

    quickSort(data, start, j - 1);  // 왼쪽 정렬
    quickSort(data, j + 1, end);    // 오른쪽 정렬
}

int main(void) {
    quickSort(data, 0, number - 1);
    show();
    return 0;
}

```

# 병합 정렬

- 반으로 나눈 후 합치면서 정렬하는 알고리즘
- 기존 데이터를 담을 추가적인 공간이 필요 → 메모리 비효율적
- 하지만 어떤 상황에서도 시간복잡도 O(N * logN)를 보장한다는 장점이 있습니다.

![image.png](./assets/병합정렬.png)

```c
#include <stdio.h>

int number = 8;                // 배열 크기

int size;
int sorted[8];                 // 정렬 임시 저장 배열 (전역으로 선언해야 재귀 호출 시 유지됨)
int count = 0;          

// 병합 과정: 두 정렬된 구간 [m ~ middle], [middle+1 ~ n]을 하나로 합침
void merge(int a[], int m, int middle, int n) {
    int i = m;
    int j = middle + 1;
    int k = m;

    // 두 구간을 비교하면서 작은 값을 sorted 배열에 넣음
    while (i <= middle && j <= n) {
        if (a[i] <= a[j]) {
            sorted[k] = a[i];
            i++;
        } else {
            sorted[k] = a[j];
            j++;
        }
        k++;
    }

    // 왼쪽 구간이 먼저 끝났을 경우 → 오른쪽 구간 남은 값 복사
    if (i > middle) {
        for (int t = j; t <= n; t++) {
            sorted[k] = a[t];
            k++;
        }
    }
    // 오른쪽 구간이 먼저 끝났을 경우 → 왼쪽 구간 남은 값 복사
    else {
        for (int t = i; t <= middle; t++) {
            sorted[k] = a[t];
            k++;
        }
    }

    // 정렬된 값들을 원래 배열로 복사
    for (int t = m; t <= n; t++) {
        a[t] = sorted[t];
    }
}

// 병합 정렬 재귀 호출
void mergeSort(int a[], int m, int n) {
    if (m < n) { // 배열 크기가 1 초과일 때만 실행
        int middle = (m + n) / 2;
        mergeSort(a, m, middle);          // 왼쪽 절반 정렬
        mergeSort(a, middle + 1, n);      // 오른쪽 절반 정렬
        merge(a, m, middle, n);           // 두 부분 병합
    }
}

int main(void) {
    int array[number] = {7, 6, 5, 8, 3, 5, 9, 1};  

    mergeSort(array, 0, number - 1); 

    for (int i = 0; i < number; i++) {
        printf("%d ", array[i]);
    }

    return 0;
}

```

# Reference

[https://m.blog.naver.com/ndb796/221227934987?recommendTrackingCode=2](https://m.blog.naver.com/ndb796/221227934987?recommendTrackingCode=2)
