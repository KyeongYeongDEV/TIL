# 에라토스테네스의 체란?

- 소수를 판별하는 알고리즘
- 2부터 N까지의 자연수 중 소수를 빠르게 판별할 수 있게 해주는 방식
- 시간 복잡도 O(N log N)

## 동작 원리
> 가장 작은 소수인 2부터 시작해서 그 배수를 모두 지우는 작업을 반복  
⇒ 남은 수는 전부 소수이다.
> 
![](./assets/에라토스테네스의체.gif)
1. 2부터 N까지 모든 수를 나열
2. 가장 작은 소수인 2부터 시작
    - 2의 배수(4,6,8, ..)를 모두 제거
3. 그 다음 남아 있는 수 중 가장 작은 소수를 판별
    - 그 수의 배수도 제거
4. 이를 √N 이하까지 반복

# 예시 코드

- `i * i` 부터 시작하는 이유
    - 중복 연산 제거
    - 이미 i보다 작은 수들이 j를 지우는 작업을 다 했기 때문
    - 예) `2 * 3 = 6`, `3 * 2 = 6` 은 이미 처리됨

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    int n = 30;
    vector<bool> isPrime(n + 1, true); // 소수인지 기록

    isPrime[0] = isPrime[1] = false; // 0과 1은 소수가 아님

    for (int i = 2; i * i <= n; i++) 
        if (isPrime[i]) {
            for (int j = i * i; j <= n; j += i)
                isPrime[j] = false;
        }
    }

    // 출력
    for (int i = 2; i <= n; i++) {
        if (isPrime[i])
            cout << i << " ";
    }
}

```
