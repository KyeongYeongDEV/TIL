# BFS와 DFS

| 항목 | BFS (Breadth-First Search) | DFS (Depth-First Search) |
| --- | --- | --- |
| 탐색 방향 | **가까운 노드부터** 탐색 | **깊은 노드부터** 탐색 |
| 자료구조 | **Queue** (FIFO) 사용 | **Stack** (재귀 or 명시적 Stack) 사용 |
| 경로 찾기 | 최단 경로 보장 (가중치 없을 때) | 최단 경로 보장 X |
| 재귀 사용 | X | 재귀 또는 명시적 스택 |
| 메모리 사용 | 보통 더 많음 (넓게 퍼짐) | 보통 더 적음 (깊게 탐색) |
| 사용 예시 | 최단 거리, 레벨 탐색 | 미로 탐색, 백트래킹 |

![image.png](./assets/bfs:dfs.png)

# 구현

## C++

```cpp
#include <iostream>
#include <queue>
#include <stack>
#include <unordered_map>
#include <vector>
#include <set>

using namespace std;

// 그래프: 문자 노드 연결
unordered_map<char, vector<char>> graph = {
    {'A', {'B', 'C'}},
    {'B', {'D', 'E'}},
    {'C', {'F'}},
    {'D', {}},
    {'E', {}},
    {'F', {}}
};

void bfs(char start) {
    queue<char> q;
    set<char> visited;

    q.push(start);

    while (!q.empty()) {
        char node = q.front(); q.pop();

        if (visited.count(node)) continue;

        cout << node << ' ';
        visited.insert(node);

        for (char neighbor : graph[node]) {
            q.push(neighbor);
        }
    }
}

void dfs(char start) {
    stack<char> s;
    set<char> visited;

    s.push(start);

    while (!s.empty()) {
        char node = s.top(); s.pop();

        if (visited.count(node)) continue;

        cout << node << ' ';
        visited.insert(node);

        // 역순으로 push해야 DFS 순서 유지됨
        for (auto it = graph[node].rbegin(); it != graph[node].rend(); ++it) {
            s.push(*it);
        }
    }
}

int main() {
    cout << "[BFS] ";
    bfs('A'); // A B C D E F
    cout << endl;

    cout << "[DFS] ";
    dfs('A'); // A B D E C F
    cout << endl;

    return 0;
}

```

## JAVA

```java
import java.util.*;

public class GraphSearch {
    static Map<Character, List<Character>> graph = new HashMap<>();

    public static void main(String[] args) {
        graph.put('A', Arrays.asList('B', 'C'));
        graph.put('B', Arrays.asList('D', 'E'));
        graph.put('C', Arrays.asList('F'));
        graph.put('D', new ArrayList<>());
        graph.put('E', new ArrayList<>());
        graph.put('F', new ArrayList<>());

        System.out.print("[BFS] ");
        bfs('A'); // A B C D E F
        System.out.println();

        System.out.print("[DFS] ");
        dfs('A'); // A B D E C F
        System.out.println();
    }

    public static void bfs(char start) {
        Queue<Character> queue = new LinkedList<>();
        Set<Character> visited = new HashSet<>();

        queue.add(start);

        while (!queue.isEmpty()) {
            char node = queue.poll();

            if (visited.contains(node)) continue;

            System.out.print(node + " ");
            visited.add(node);

            for (char neighbor : graph.get(node)) {
                queue.add(neighbor);
            }
        }
    }

    public static void dfs(char start) {
        Stack<Character> stack = new Stack<>();
        Set<Character> visited = new HashSet<>();

        stack.push(start);

        while (!stack.isEmpty()) {
            char node = stack.pop();

            if (visited.contains(node)) continue;

            System.out.print(node + " ");
            visited.add(node);

            List<Character> neighbors = graph.get(node);
            // 역순 push: DFS 순서 유지
            for (int i = neighbors.size() - 1; i >= 0; i--) {
                stack.push(neighbors.get(i));
            }
        }
    }
}

```
# Union-Find(Disjoint Set Union, DSU, 합집합)

> 여러 개의 노드가 있을 때, 어떤 노드들이 같은 그룹(집합)에 속해 있는지 빠르게 판별
> 
> 
> 서로 다른 두 그룹을 **하나의 그룹으로 합칠 수 있는 자료구조**
> 
- MST (최소 신장 트리, Kruskal 알고리즘)에 사용

![image.png](./assets/유니온.png)

- 0 단계 : 각 원소가 자기 자신을 루트로 가짐 (대표노드 = 자기 자신)
- 1단계 : Union(1, 2)
    - 1의 루트 : 1
    - 2의 루트 : 2
    - 서로 다르니 2를 1에 붙인다 → **1이 대표 루트**
- 2단계 : Union(3, 5)
    - 3의 루트 : 3
    - 5의 루트 : 5
    - 5를 3에 붙인다 → **3이 대표 루트**
- 3단계 : Union(1, 4)
    - 1의 루트 : 1
    - 4의 루트 : 4
    - 4를 1에 붙임 → **1이 대표**
- 4단계 : Find(x) 결과
    
    
    | 노드 | 루트(대표) |
    | --- | --- |
    | 1 | 1 |
    | 2 | 1 |
    | 4 | 1 |
    | 3 | 3 |
    | 5 | 3 |
    | 6 | 6 |
- 5단계 : Union(1, 5)
    - 1의 루트 : 1
    - 5의 루트 : 3
        
        → 서로 다른 그룹이므로 합침 → 보통은 **숫자가 작은 쪽**을 루트로 잡는다.
        
        → 여기선 **3을 1 밑에 붙임**
        

## 예시 코드

```java
public class UnionFind {
    private int[] parent;

    // 생성자: 초기화
    public UnionFind(int size) {
        parent = new int[size + 1]; // 보통 1번부터 사용하니까 size+1
        for (int i = 1; i <= size; i++) {
            parent[i] = i; // 자기 자신이 루트
        }
    }

    // find: 루트 노드 찾기 + 경로 압축
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]); // 경로 압축
        }
        return parent[x];
    }

    // union: 두 집합 합치기
    public void union(int a, int b) {
        int rootA = find(a);
        int rootB = find(b);

        if (rootA != rootB) {
            // 작은 루트를 기준으로 합침 (선택적)
            if (rootA < rootB) {
                parent[rootB] = rootA;
            } else {
                parent[rootA] = rootB;
            }
        }
    }

    // 같은 집합인지 확인
    public boolean isConnected(int a, int b) {
        return find(a) == find(b);
    }

    // 상태 출력 (디버깅용)
    public void printParent() {
        System.out.print("Parent Array: ");
        for (int i = 1; i < parent.length; i++) {
            System.out.print(parent[i] + " ");
        }
        System.out.println();
    }

    // 테스트
    public static void main(String[] args) {
        UnionFind uf = new UnionFind(6); // 1~6번 노드

        uf.union(1, 2);
        uf.union(3, 5);
        uf.union(1, 4);

        uf.printParent(); // 상태 확인

        System.out.println("Find(2): " + uf.find(2)); // 루트: 1
        System.out.println("Find(5): " + uf.find(5)); // 루트: 3

        uf.union(1, 5); // 1번 집합과 3번 집합 연결

        uf.printParent(); // 최종 상태
        System.out.println("Find(5): " + uf.find(5)); // 루트: 1
    }
}

```

# Reference

[https://m.blog.naver.com/ndb796/221230967614?recommendTrackingCode=2](https://m.blog.naver.com/ndb796/221230967614?recommendTrackingCode=2)

[https://velog.io/@jinh2352/유니온-파인드-기초-이코테](https://velog.io/@jinh2352/%EC%9C%A0%EB%8B%88%EC%98%A8-%ED%8C%8C%EC%9D%B8%EB%93%9C-%EA%B8%B0%EC%B4%88-%EC%9D%B4%EC%BD%94%ED%85%8C)
