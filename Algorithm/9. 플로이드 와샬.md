# 플로이드 와샬 알고리즘이란?

- 모든 정점 쌍 간의 최단 거리를 구하는 DP기반 알고리즘

| 항목 | 내용 |
| --- | --- |
| **용도** | 모든 정점에서 모든 정점까지의 최단 거리 계산 (음의 가중치 허용, `음수 사이클은 x`) |
| **시간복잡도** | O(V³) (V = 노드 수) |
| **기본 아이디어** | 거쳐 가는 노드 k를 하나씩 증가시키며, `i → j`로 가는 경로를 `i → k → j`로 `우회(경우)`해서 가는 경우가 더 짧은지 확인 |
| **초기화** | `dist[i][j] = INF` (단, `i == j`이면 0, 간선 있으면 해당 가중치) |

# 알고리즘 공식 (DP 점화식)

```cpp
for (int k = 1; k <= V; ++k)
    for (int i = 1; i <= V; ++i)
        for (int j = 1; j <= V; ++j)
            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
```

- `dist[i][j]`는 i에서 j까지 가는 최단 거리
- k는 중간 노드 (경유지)
- i → k → j 경로가 더 짧다면 업데이트

## 적용 예시

1. k = 1 부터 k = 5까지 모든 노드를 경유지로 설정
2. 각 `i`, `j`쌍에 대해 `dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])` 수행
    - 예)
    - `dist[2][3]`은 원래 4
    - 만약 `dist[2][1] + dist[1][3] = 3 + 8 = 11`이라면
        
        → 더 크므로 무시
        
    - 반대로 `dist[2][4] = ∞`, `dist[2][3] = 4`, `dist[3][4] = -5`라면
        
        `dist[2][4] > dist[2][3] + dist[3][4] = 4 + (-5) = -1`
        
        → 갱신됨
        

# 코드

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int INF = 1e9;
int n, m; // 노드 수, 간선 수
int dist[101][101];

int main() {
    cin >> n >> m;
    
    // 초기화
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            dist[i][j] = (i == j ? 0 : INF);

    // 간선 정보 입력
    for (int i = 0; i < m; ++i) {
        int a, b, c; // a -> b 가중치 c
        cin >> a >> b >> c;
        dist[a][b] = c;
    }

    // 플로이드 워셜
    for (int k = 1; k <= n; ++k)
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j)
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);

    // 결과 출력
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (dist[i][j] == INF) cout << "INF ";
            else cout << dist[i][j] << " ";
        }
        cout << "\n";
    }

    return 0;
}

```
