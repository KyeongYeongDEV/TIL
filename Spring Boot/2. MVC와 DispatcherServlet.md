# Spring MVC 흐름 & DispatcherServlet 구조

스프링 웹 개발을 하다보면 `Controller`에 `@GetMapping`만 붙이면 잘 동작하는데,
요청이 어떻게 `Controller`까지 도달하는지, 내부에선 어떤 컴포넌트들이 동작하는지 알아봅시다.

# DispatcherServlet이란?

`DispatcherServlet`은 Spring `MVC`의 프론트 컨트롤러입니다.
모든 요청을 가로채서, 적절한 컨트롤러에 위임하고, 결과를 응답으로 반환합니다.

> Spring Boot는 DispatcherServlet을 자동으로 등록해주며, 기본 경로 `/`에 매핑됩니다.
> 

## MVC 요청 흐름

1. 클라이언트 요청 → DispatcherServlet
    - 사용자가 /user로 요청을 보내면
    - DispatcherServlet이 모든 요청을 먼저 받습니다.
    - web.xml 또는 Spring Boot 자동 등록됨
2. HandlerMapping
    - DispatcherServlet은 현재 요청을 처리할 컨트롤러를 찾아야 하므로,
    - HandlerMapping을 통해 어떤 메서드에 연결할지 조회합니다.
    - 예) `/user` 요청 → `UserController.getUser()`로 매핑
3. HandlerAdapter
    - `HandlerMapping`이 컨트롤러를 찾았다면,
    - 이제 해당 컨트롤러를 실행하는 방식(호출 방법)을 `HandlerAdapter`가 결정합니다.
4. Controller 실행
    
    ```java
    @Controller
    public class UserController {
        @GetMapping("/user")
        public String getUser(Model model) {
            model.addAttribute("name", "길동");
            return "user"; // 논리적 뷰 이름 반환
        }
    }
    ```
    
5. ViewResolver
- `return “user”`이라는 논리 뷰 이름으로,
- ViewResolver가 실제 뷰 파일(`/WEB-INF/views/user.jsp` 등 )을 찾아 View 객체를 생성합니다.
    
    ```yaml
    # application.yml 예시
    spring:
      mvc:
        view:
          prefix: /WEB-INF/views
          suffix: .jsp
    ```
    
1. View.render()
    - View 객체가 생성되면, render() 메서드를 통해 HTML을 렌더링하고
    - DispatcherServlet을 통해 클라이언트에 응답이 전송됩니다.

## 예시 코드

UserController.java

```java
@Controller
public class UserController {

    @GetMapping("/user")
    public String userPage(Model model) {
        model.addAttribute("nickname", "세윤");
        return "user"; // → /WEB-INF/views/user.jsp
    }
}
```

user.jsp

```java
<%@ page contentType="text/html;charset=UTF-8" %>
<html>
  <body>
    <h1>안녕하세요, ${nickname}님!</h1>
  </body>
</html>
```

### 동작 설명

1. 클라이언트가 브라우저에서 `/user` 요청을 보냈다
2. DispatcherServlet이 이 요청을 받는다
    - Spring Boot에서는 기본적으로 모든 요청이 `DispatcherServlet`으로 들어감
3. HandlerMapping이 Controller를 찾는다.
    - Spring은 @GetMapping(”/user”)라는 어노테이션을 스캔하고
    이 요청은 UserCotroller.userPage()가 처리하는 것이라고 판단한다.
    - `RequestMappingHandlerMapping`이 담담한다.
4. HandlerAdapter가 Controller 메서드를 실행
    - `RequestMappingHandlerAdapter`가 호출됨
    - `Model` 객체도 자동으로 만들어져서 파라미터로 주입됨
    - `model.addAttribute("nickname", "길동");`
        - 이걸로 `nickName=길동`이 model에 들어간다
5. `return “user”` → ViewResolver가 뷰 경로를 매핑
6. JSP 렌더링 (View.render)
    - JSP 내부에서 `${nickname}`은 model에서 온 값을 바인딩해서 HTML 생성
7. DispatcherServlet이 응답을 HTTP로 반환
    - 이 HTML이 다시 DispatcherServlet을 거쳐서
    - HTTP Response로 클라이언트에게 전송됨.

## DispatcherServlet 내부 구성 요소

- Filter - 서블릿 전처리기 (인코딩, CORS 등)
- Intercepter - 요청/응답 전후에 동작하는 미들웨어
- HandlerMapping - 어떤 컨트롤러가 요청을 처리할지 결정
- HandlerAdapter - 컨트롤러 메서드 실행
- Controller - 비즈니즈 로직 처리
- ViewResolver - 뷰 이름 → 뷰 객체로 변환
- View - 실제 HTML 등 렌더링 수행

## Filter vs Interceptor vs AOP 차이

| 구분 | 시점 | 범위 | 주요 용도 |
| --- | --- | --- | --- |
| Filter | DispatcherServlet 이전 | 서블릿 전 범위 | 인코딩, CORS, 로그 |
| Interceptor | DispatcherServlet 이후, Controller 이전 | Handler 수준 | 인증, 권한 확인, 로그 |
| AOP | Bean 내부 메서드 호출 시점 | 빈 내부 호출 | 트랜잭션, 로깅, 캐싱 |

> 인터셉터 → HandlerInterceptor 구현
> 
> 
> 필터 →  `Filter` 인터페이스 구현 (서블릿 레벨)
> 

# 정리

- DispatcherServlet -
    - Spring MVC의 중심, 모든 요청의 시작점
- HandlerMapping
    - 요청 URI에 맞는 컨트롤러 탐색
- HandlerAdapter
    - 컨트롤러를 실제로 호출하는 실행자
- ViewResolver
    - 논리 뷰 이름을 실제 뷰로 변환
- View
    - HTML 렌더링 수행
- 필터, 인터셉터, AOP
    - 동작 시점과 대상이 서로 다름, 용도에 따라 구분

> @Controller, @GetMapping만으로 웹이 동작하는 이유는
그 아래에서 DispatcherServlet이 모든 흐름을 조율하고 있기 때문입니다.
> 

# Reference

[https://bcuts.tistory.com/431](https://bcuts.tistory.com/431)
