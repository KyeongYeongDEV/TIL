# 쿠키와 세션의 차이에 대해 설명해 주세요.

## 1. 쿠키와 세션 차이

> 
> 
> 
> 네, 쿠키와 세션은 둘 다 사용자 인증 상태를 유지하기 위해 사용됩니다.
> 쿠키는 **클라이언트(브라우저)에 저장되는 데이터**로, 사용자 측에 상태 정보를 담고 있기 때문에 **보안에 취약**할 수 있습니다.
> 반면 세션은**서버 측에 저장**되며, 브라우저는 세션을 식별할 수 있는**세션 ID만 쿠키에 저장**해 전송합니다.
> 보안상으로는 세션이 더 안전하지만, **서버 자원을 더 사용**하기 때문에 규모에 따라 트레이드오프가 존재합니다.
> 

| 항목 | 쿠키 (Cookie) | 세션 (Session) |
| --- | --- | --- |
| 저장 위치 | **클라이언트(브라우저)** | **서버** |
| 용량 제한 | 약 **4KB** | 서버 메모리 크기에 의존 |
| 보안 | 클라이언트에 저장되므로 **변조/탈취 위험** 존재 | 서버에 저장되어 **상대적으로 안전** |
| 유지 기간 | 브라우저 종료 후에도 유지 가능 (만료 시각 설정 가능) | 기본적으로 **브라우저 종료 시 소멸** |
| 사용 예 | 자동 로그인, 장바구니 | 로그인 인증 정보, 사용자 상태 저장 |

## 2. 세션 방식의 로그인 과정

> 세션 로그인은 사용자가 로그인시, 서버가 고유한 세션 ID를 생성하고 클라이언트의 쿠키에 세션 ID를 저장합니다.
이후 사용자는 요청마다 이 세션 ID를 함께 보내고, 서버는 세션 ID를 기준으로 사용자 정보를 찾아 s인증 상태를 유지합니다. 
세션 데이터는 서버 메모리 또는 Redis 등 세션 저장소에 저장됩니다.
> 
1. 사용자가 로그인 요청을 보낸다 (아이디 / 비밀번호)
2. 서버는 사용자의 정보가 맞으면 `세션 ID`를 생성한다.
3. 이 `세션 ID`는  `쿠키`로 client(브라우저)에 저장이 된다
4. 이후 요청시, client는 이 `세션 ID`가 담긴 `쿠키`를 함께 전송한다.
5. 서버는 이 `세션 ID`를 바탕으로 로그인 상태를 확인하고 요청을 처리한다.

즉, `세션`은 서버가 사용자 상태를 기억하는 방식이고, `쿠키`는 `세션 ID` 전달 수단으로 활용된다.

## 3. HTTP의 Stateless란?

> HTTP는 기본적으로 Stateless 프로토콜이라, 서버의 요청 간의 상태를 기억하지 않습니다.
즉, 매 요청마다 인증 정보 등 필요한 데이터를 항상 포함해서 보내야 하며, 
이 덕분에 확장성과 단순성이 뛰어나지만, 사용자 상태 유지에는 추가 구조가 필요합니다.
> 
- HTTP는 기본적으로 Stateless(무상태) 프로토콜이다
- 즉, 각 요청은 독립적이며, **이전 요청의 상태를 기억하지 않는다.**
- `서버`는 `“누가”`, `“무엇을 했는지”` 기억하지 않기 때문에, 로그인 정보도 매 요청마다 포함해야 한다.

## 4. Stateless 환경에서 세션은 부적절한 인증 방식 아닌가요?

> 맞습니다.
Statless한 HTTP에서는 상태를 저장하지 않는 것이 원칙인데
세션은 서버 측에 상태 정보를 저장하므로 HTTP의 Stateless 원칙에 어긋납니다.
그래서 규모가 큰 시스템이나 RESTful API에서는 주로 JWT 같은 토큰 기반 인증이 선호됩니다.
토큰은 클라이언트가 인증 상태를 자체 보관하므로 완전한 Stateless 구조를 유지할 수 있습니다.
> 
- 엄밀히 말하자면 세션은 Stateless에 위배된다.
- 서버가 `사용자 상태를 저장`한다는 점에서 상태를 `유지`하는 구조입니다.
- 그래서 Stateless 구조에서는 토큰 기반 인증 (ex : JWT)이 더 적합
- 즉, 세션은 관리가 편하지만 서버가 상태를 관리해야 하고, 토큰(JWT)는 완전한 Stateless 환경에서 선호됩니다.

## 5. 서버가 여러 대일 경우 세션은 어떻게 관리할 수 있나요?

> 서버가 여러 대인 환경에서는 세션을 중앙에서 관리할 수 있는 방식이 필요합니다.
대표적인 방법으로는 xxx세션이 있고 설명~~
이 중에서 스케일 아웃이 쉬운 방식은 보통 2번과 3번입니다.
> 

| 방법 | 설명 |
| --- | --- |
| **Sticky Session (Session Affinity)** | 사용자의 요청을 항상 **같은 서버**로 보내도록 로드밸런서가 유지함 (ex. Nginx `ip_hash`) |
| **Session Store 사용** | Redis, Memcached 같은 **공용 세션 저장소**에 세션을 저장해 **모든 서버가 공유** |
| **JWT 토큰 사용 (Stateless 인증)** | 아예 서버에 상태를 저장하지 않고, 클라이언트에 로그인 정보를 포함시킴 |
