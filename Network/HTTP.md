# HTTP 응답 코드에 대해 설명해주세요

## 0. HTTP 응답 코드란?

> HTTP 응답코드는 클라이언트의 요청에 대해 서버가 어떤 상태인지 숫자로 알려주는 표준입니다.
> 
> 
> 총 5개의 범주로 나뉘며, `2백 번대`는 성공, `4백 번대`는 클라이언트 오류, `5백 번대`는 서버 오류를 의미합니다.
> 
> 예를 들어 200은 성공, 404는 리소스를 찾을 수 없음, 500은 서버 에러를 나타냅니다.
> 

---

**HTTP 응답코드**는 클라이언트 요청에 대한 서버의 응답 상태를 숫자로 나타내는 표준입니다.

총 5가지 범주로 나뉩니다:

| 범주 | 의미 |
| --- | --- |
| 1xx | 정보 응답 (처리 중) |
| 2xx | 성공 응답 (요청 성공) |
| 3xx | 리다이렉션 (다른 위치로 이동) |
| 4xx | 클라이언트 오류 (잘못된 요청) |
| 5xx | 서버 오류 (서버 내부 문제) |

## 1. 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?

> `401`은 인증이 안 되었거나 유효하지 않은 경우고,
`403`은 인증은 됐지만 접근 권한이 없는 경우입니다.
예를 들어 로그인 안 한 사용자가 접근하면 401,
로그인했어도 관리자 권한이 없으면 403이 됩니다.
> 

---

| 항목 | 401 Unauthorized | 403 Forbidden |
| --- | --- | --- |
| 의미 | **인증이 필요하거나 실패한 경우** | **인증은 되었지만 권한이 없는 경우** |
| 상황 예시 | 로그인하지 않고 접근 / 토큰 없음 | 로그인했지만 관리자 권한이 없음 |
| 헤더 | `WWW-Authenticate` 헤더가 포함될 수 있음 | 보통 포함되지 않음 |

> 📌 요약:
> 
> 
> `401` = "너 로그인 안 했어"
> 
> `403` = "너 로그인 했지만, 이건 못 봐"
> 

## 2. 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.

> 200 OK는 요청이 정상 처리됐을 때,
201 Created는 요청으로 인해 새로운 리소스가 생성되었을 때 사용됩니다.
예를 들어 GET 요청은 200, POST로 새 유저를 생성하면 201이 적절합니다.
> 

---

| 항목 | 200 OK | 201 Created |
| --- | --- | --- |
| 의미 | 요청이 **정상 처리됨** | 요청으로 인해 **리소스가 생성됨** |
| 용도 | GET, PUT, DELETE 등에서 주로 사용 | POST 요청에서 새 리소스 생성 시 사용 |
| 응답 내용 | 리소스 상태 반환 | 생성된 리소스의 URI 포함 가능 (`Location` 헤더) |

> 📌 예시:
> 
> - `GET /users/1` → 200 OK
> - `POST /users` → 201 Created + 새로 생성된 `/users/2`

## 3. 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.

> HTTP 응답코드는 IANA에 등록된 표준 코드만 사용하는 것이 원칙입니다.
285처럼 임의의 코드를 쓰면 브라우저나 프록시가 정상 처리하지 못할 수 있어 비표준으로 간주됩니다.
대신 404 리소스를 찾을 수 없음 처럼 이미 정의된 코드를 의미에 맞게 사용하는 것이 안전합니다.
> 

---

**원칙적으로는 불가능합니다.**

- HTTP 상태코드는 IANA에서 **정해진 표준 코드만 사용**해야 합니다.
- **100~599 사이의 코드 중 등록된 코드만 유효**합니다.

> ❗285번처럼 임의의 코드를 사용하면:
> 
> - 일부 브라우저나 프록시가 **이상 동작**할 수 있음
> - API 문서화/호환성/에러처리에서 **예측 불가능한 오류** 발생 가능

📌 **대신** 표준 범위 내에서 의미를 부여해서 사용하는 게 일반적입니다.

예:

- `422 Unprocessable Entity` (폼 검증 실패)
- `409 Conflict` (중복 리소스 충돌)

# HTTP Method에 대해 설명해주세요

> HTTP Method는 클라이언트가 서버에게 어떤 동작을 수행하길 원하는지를 정의한 동사입니다.
> 
> 
> 주요 메서드들은 다음과 같습니다:
> 

| Method | 설명 |
| --- | --- |
| **GET** | 리소스를 조회할 때 사용합니다. |
| **POST** | 새로운 리소스를 생성하거나 처리할 때 사용합니다. |
| **PUT** | 전체 리소스를 대체할 때 사용합니다. |
| **PATCH** | 리소스의 일부를 수정할 때 사용합니다. |
| **DELETE** | 리소스를 삭제할 때 사용합니다. |

## 1. HTTP Method의 **멱등성(idempotence)** 이란?

> 멱등성은 같은 요청을 여러 번 반복해서 보내도 결과가 같음을 의미합니다.
> 

| Method | 멱등성 | 설명 |
| --- | --- | --- |
| GET | ✅ | 여러 번 조회해도 데이터에 영향 없음 |
| PUT | ✅ | 같은 데이터로 갱신하면 결과는 동일 |
| DELETE | ✅ | 이미 삭제된 리소스를 또 삭제해도 영향 없음 |
| POST | ❌ | 여러 번 호출하면 여러 개가 생성될 수 있음 |
| PATCH | ❌ | 부분 변경이므로 호출마다 결과가 달라질 수 있음 |

## 2. GET과 POST의 차이는?

> GET은 리소스를 **조회**할 때 사용하며, 브라우저 캐싱이 가능하고 멱등성도 보장됩니다.
> 
> 
> 반면 POST는 **데이터를 생성하거나 처리**할 때 사용하며, Body에 정보를 담아 전송하고 멱등성이 없습니다.
> 

| 항목 | GET | POST |
| --- | --- | --- |
| 목적 | 데이터 조회 | 데이터 생성/처리 |
| 데이터 위치 | URL의 쿼리 파라미터 | HTTP Body |
| 캐싱 | ✅ 가능 | ❌ 일반적으로 불가 |
| 멱등성 | ✅ 있음 | ❌ 없음 |
| 사용 예시 | `/users?id=1` | `/users` + Body에 `{name: "Tom"}` |

## 3. POST vs PUT vs PATCH

> POST는 새로운 리소스를 생성할 때, PUT은 전체 리소스를 대체할 때, 
PATCH는 부분 수정할 때 사용합니다. 
PUT은 멱등하지만 POST와 PATCH는 멱등하지 않습니다.
> 

| Method | 목적 | 리소스 상태 | 멱등성 |
| --- | --- | --- | --- |
| **POST** | 새 리소스 생성 | 생성될 리소스 ID가 서버에 의해 정해짐 | ❌ |
| **PUT** | 전체 리소스 교체 | 존재하면 갱신, 없으면 생성 (UPSERT) | ✅ |
| **PATCH** | 리소스의 일부 수정 | 기존 리소스의 일부분만 갱신 | ❌ |

## 4. HTTP 1.1 이후 GET에도 Body를 실을 수 있게 되었는데 왜 사용하지 않나요?

> HTTP 1.1 사양상 GET 요청에도 Body를 포함하는 것이 기술적으로는 가능합니다.
> 
> 
> 하지만 일반적으로 **GET 요청에 Body를 실어 보내는 것을 지양**합니다.
> 
> 이유는 
> 
1. **표준 관행과 호환성 문제**
    
    대부분의 프록시, 캐시 서버, 그리고 일부 백엔드 서버는 GET Body를 **무시하거나 아예 처리하지 않는 경우가 많습니다.**
    
    또한 많은 HTTP 클라이언트 라이브러리도 GET Body를 **명확하게 지원하지 않아** 예기치 않은 동작을 유발할 수 있습니다.
    
2. **설계 원칙 훼손 방지**
    
    GET은 본질적으로 **안전하고 멱등한(read-only)** 요청이어야 합니다.
    
    Body에 의미 있는 데이터를 실어 보내게 되면, 이 원칙을 **명확히 보장하기 어려워지며 설계 철학에 어긋날 수 있습니다.**
    
3. **캐싱 정책 혼란**
    
    HTTP 캐시는 보통 **URL과 쿼리 스트링** 기준으로 동작하기 때문에, Body에 포함된 정보는 **캐시 관점에서 무시**됩니다.
    
    이는 예기치 않은 동작이나 캐시 누락을 초래할 수 있습니다.
    

> 따라서, 일반적으로 GET 요청은 Body 없이 명확하게 조회용으로만 사용하고,
> 
> 
> **POST나 PUT 같은 메서드**를 통해 본문을 사용하는 방식이 표준적으로 자리 잡고 있습니다.
> 

# HTTP에 대해 설명해주세요

HTTP는 **HyperText Transfer Protocol**의 약자이며,
웹에서 **클라이언트(브라우저)와 서버 간 데이터를 주고받기 위한 통신 규약**입니다.
기본적으로는 텍스트 기반이며, 요청(Request)과 응답(Response) 구조로 동작합니다.

예를 들어 브라우저에서 어떤 URL에 접속하면 클라이언트는 `GET` 요청을 보내고 서버는 HTML, JSON 등의 데이터를 응답합니다.

또한 HTTP는 **Stateless**한 프로토콜이기 때문에 요청 간의 상태를 유지하지 않으며 이로 인해 빠르고 확장성 좋은 구조가 가능하지만 인증, 세션 유지 등을 위해 별도의 쿠키, 세션, 토큰 등의 기술이 필요합니다.

## 1. 공개키와 대칭키에 대해 설명해주세요

`대칭키`는 암호화와 복호화에 같은 키를 사용하는 방식입니다.
속도가 빠르고 구현이 간단하지만 키가 노출되면 보안에 취약합니다.

반면 공개키 기반 암호화는 공개키로 암호화하고 개인키로 복호화하는 구조입니다.
서버는 개인키를 가지고 있고, 클라이언트는 공개키를 받아 통신합니다.

- 공개키 방식은 키 분배 문제가 없지만 속도가 느립니다.
- 대칭키는 속도가 빠르지만 키를 안전하게 전달해야 한다는 문제가 있습니다

그래서 일반적으로 이 두 가지 방식을 `혼합`해서 사용합니다(아래에서 설명)

## 2. 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것일까

`HTTPS`는 `HTTP`에 `SSL/TLS` 암호화를 입힌 것입니다.
초기 Handshake 과정에서 공개키 기반 암호화를 사용해 대칭키를 안전하게 교환합니다.

이때 공개키를 아무나 전달하면 중간자 공격(MITM)의 위험이 있기 때문에,
서버가 진짜라는 걸 증명하기 위한 신뢰된 인증기간(CA)이 발급한 인증서를 사용합니다.

즉, 인증서는 서버의 신원과 공개키가 진짜임을 증명해주는 역할입니다.

- 클라이언트는 인증서를 보고 이 서버가 신뢰할 수 있는 곳인지 확인하고
- 이후 전달되는 대칭키는 안전하게 보호되며
- 이후부터는 대칭키로 빠르고 효율적으로 데이터를 암호화하여 주고받게 됩니다.

## 3. SSL과 TLS의 차이는 무엇인가요

`SSL(Secure Sockets Layer)`는 넷스케이프가 처음 만든 보안 프로토콜이고,

`TLS(Transport Layer Security)`는 그 후계자이자 표준입니다.

즉, **TLS는 SSL의 개선 버전**이며,

현재는 SSL 3.0까지 존재했고, 이후는 모두 TLS 1.0 이상입니다.

> 일반적으로 "SSL 인증서"라고 부르지만, 실제 프로토콜은 대부분 TLS 1.2나 1.3입니다.
> 

| 구분 | SSL | TLS |
| --- | --- | --- |
| 표준화 | 비표준 (넷스케이프) | IETF 표준 |
| 보안성 | 취약점 존재 (3.0까지) | 강화된 보안 (TLS 1.2, 1.3 권장) |
| 사용 여부 | 더 이상 사용 안 함 | 현재 대부분 TLS 1.2 또는 1.3 사용 |
