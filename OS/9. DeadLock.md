## **1. Deadlock(교착 상태) 개념**

- **정의**: 둘 이상의 프로세스가 서로가 가진 자원을 기다리며 **무한 대기 상태**에 빠져버리는 현상.
- 예시: A가 프린터, B가 스캐너를 잡고 있는데, A는 스캐너를, B는 프린터를 기다리는 경우 → 둘 다 영원히 대기.

---

## **2. Deadlock 발생 4가지 조건** *(Coffman’s Conditions)*

1. **상호 배제(Mutual Exclusion)**
    
    → 자원은 동시에 한 프로세스만 사용 가능.
    
2. **점유와 대기(Hold and Wait)**
    
    → 최소 1개 자원을 점유한 채 다른 자원을 기다림.
    
3. **비선점(No Preemption)**
    
    → 다른 프로세스가 점유한 자원을 강제로 빼앗을 수 없음.
    
4. **순환 대기(Circular Wait)**
    
    → 프로세스들이 원형으로 서로의 자원을 기다림.
    

---

## **3. 왜 3가지만 충족하면 Deadlock이 발생하지 않는가?**

- Deadlock은 **위 4가지 조건이 모두 동시에 성립**해야 발생함.
- 하나라도 깨지면, 무한 대기 상태가 깨지고 언젠가 자원 확보 가능.
- 예: 비선점 조건을 없애면, 기다리지 않고 자원을 강제로 회수 가능 → Deadlock 해소.

---

## **4. Deadlock 예방 방법**

- **상호 배제 방지**: 여러 프로세스가 동시에 접근 가능한 자원으로 설계 (현실적으로 어려움).
- **점유와 대기 방지**: 자원을 요청할 때 전부 확보하거나, 아무것도 없는 상태에서만 요청.
- **비선점 방지**: 다른 프로세스가 자원 요청 시, 현재 점유 자원을 강제로 해제.
- **순환 대기 방지**: 자원에 고유 번호를 부여하고, 항상 번호가 증가하는 순서로만 요청.

---

## **5. 왜 현대 OS는 Deadlock을 직접 처리하지 않을까?**

- **이유**
    - Deadlock 탐지·회복 로직이 복잡하고 성능 저하 유발.
    - 자원 요청 순서 보장, 강제 회수 같은 정책이 프로그램의 자유도 감소.
    - 대부분의 애플리케이션이 Deadlock 가능성을 낮추도록 설계됨.
- **대신**
    - 프로그래머가 Lock 순서를 설계하거나, 타임아웃 설정 등으로 회피.
    - OS는 일부 IPC나 커널 내부 Lock에만 Deadlock 회피 로직 사용.

---

## **6. Wait-Free vs Lock-Free**

- **Wait-Free**
    - 모든 스레드가 **유한한 시간 내**에 작업 완료 보장.
    - 절대 굶주림(Starvation) 없음.
    - 구현 난이도↑, 오버헤드↑.
- **Lock-Free**
    - 시스템 전체가 계속 전진(progress)한다는 보장.
    - 한 스레드가 무한 대기에 빠질 가능성은 있으나, 전체적으로는 계속 처리됨.
    - Wait-Free보다 구현이 쉬움.

---

📌 **정리 표**

| 구분 | Deadlock | Wait-Free | Lock-Free |
| --- | --- | --- | --- |
| 의미 | 무한 대기 상태 | 모든 스레드가 유한 시간 내 완료 보장 | 전체 시스템의 진행 보장 |
| 원인/특징 | Coffman 4조건 모두 충족 | Starvation 없음 | 일부 스레드는 Starvation 가능 |
| 해결/목적 | 조건 깨뜨리기 | 실시간성 보장 | 동시성 성능 향상 |

# 면접 대답

## **1. Deadlock이란?**

> "Deadlock은 두 개 이상의 프로세스가 서로가 가진 자원을 기다리며 무한 대기 상태에 빠지는 현상입니다."
> 

---

## **2. Deadlock 발생 4가지 조건**

> "상호 배제, 점유와 대기, 비선점, 순환 대기입니다.
4가지 조건이 모두 만족될 때만 Deadlock이 발생합니다."
> 

---

## **3. 3가지만 충족하면 왜 Deadlock이 안 생기나?**

> "Deadlock은 네 가지 조건이 모두 충족돼야 발생하기 때문에,
하나라도 깨지면 자원을 기다림 없이 회수하거나 요청 순서를 바꿔서 결국 해소됩니다."
> 

---

## **4. Deadlock 예방 방법**

> "상호 배제를 없애거나, 점유와 대기를 방지하고, 비선점 허용, 순환 대기 방지 중 하나 이상을 적용하면 예방 가능합니다.
예를 들어 자원에 번호를 매기고 항상 증가하는 순서로 요청하는 방법이 있습니다."
> 

---

## **5. 현대 OS가 Deadlock을 직접 처리하지 않는 이유**

> "탐지와 회복이 복잡하고 성능 저하가 크며, 애플리케이션 설계에서 대부분 회피가 가능하기 때문입니다.
대신 커널 내부나 특정 IPC에만 제한적으로 회피 기법을 사용합니다."
> 

---

## **6. Wait-Free vs Lock-Free**

> "Wait-Free는 모든 스레드가 유한한 시간 내 작업 완료를 보장해 Starvation이 없습니다.
Lock-Free는 전체 진행은 보장하지만 일부 스레드가 무한 대기에 빠질 수 있습니다."
>
