## 1. 프로세스 스케줄링 알고리즘 종류

대표적인 건 이 정도야:

- **FCFS (First Come First Served)**
    
    줄 선 순서대로 처리. 단순하지만 Convoy Effect(느린 놈 때문에 뒤가 막힘) 있음.
    
- **SJF (Shortest Job First)**
    
    CPU Burst가 짧은 프로세스 먼저 실행. 평균 대기 시간 최소화. 하지만 CPU Burst 예측이 어려움.
    
- **SRTF (Shortest Remaining Time First)**
    
    SJF의 선점형 버전. 남은 시간이 더 짧은 프로세스가 오면 바로 갈아탐.
    
- **RR (Round Robin)**
    
    Time Slice(퀀텀) 단위로 번갈아 실행. 공정성 좋음. Time Slice 설정이 핵심.
    
- **Priority Scheduling**
    
    우선순위 높은 프로세스 먼저. 하지만 기아(Starvation) 문제 생김.
    
- **MLFQ (Multi-Level Feedback Queue)**
    
    여러 개의 우선순위 큐를 두고, CPU 점유 시간·응답 패턴에 따라 큐 이동. CPU-bound는 아래로, I/O-bound는 위로.
    

---

## 2. RR(Time Slice)에서의 Trade-off

- **짧은 Time Slice**
    
    → 응답성(Response Time) 좋아짐
    
    → BUT, Context Switching이 너무 자주 일어나서 오버헤드↑
    
- **긴 Time Slice**
    
    → Context Switching 오버헤드 줄어듦
    
    → BUT, 사실상 FCFS처럼 돼서 응답성이 떨어짐
    
    **정리:** 너무 짧으면 오버헤드 지옥, 너무 길면 응답성 저하 → 둘 사이 밸런스가 핵심.
    

---

## 3. 싱글 스레드 CPU에서 상시 돌아야 하는 프로세스

- **추천:** **Priority Scheduling** (혹은 Real-Time Scheduler - Rate Monotonic, EDF 같은 것)
- **이유:** 상시로 돌아야 한다는 건 실시간 성격이 강하다는 거라, 우선순위를 높여서 항상 CPU를 먼저 잡게 해줘야 함.
    
    RR이나 FCFS 쓰면 다른 프로세스에 막혀서 지연될 수 있음.
    

---

## 4. 동시성과 병렬성 차이

- **동시성 (Concurrency)**
    
    → 한 개의 CPU에서 시분할로 여러 작업을 번갈아 처리하는 것. 동시에 하는 것처럼 "보이는" 것.
    
- **병렬성 (Parallelism)**
    
    → 진짜로 물리적으로 여러 CPU 코어에서 동시에 처리하는 것.
    
    **비유:** 동시성은 식당에서 종업원 1명이 테이블 여러 개 번갈아 서빙, 병렬성은 종업원 여러 명이 각 테이블 맡아서 동시에 서빙.
    

---

## 5. MLFQ가 해결하는 문제점

- **SJF의 예측 불가 문제 해결**
    
    → 처음엔 높은 우선순위로 주고, CPU 점유 시간 길면 점점 우선순위 낮춤.
    
- **Priority Scheduling의 기아 문제 해결**
    
    → 오래 기다린 프로세스는 우선순위 올려줌(aging).
    
- **RR의 공정성 + 우선순위 기반 응답성 확보**
    
    → I/O-bound 프로세스가 빠르게 응답 가능.
    

---

## 6. FIFO 스케줄러 쓸모?

- 쓸모없지 않음.
- **적합 시나리오:**
    - 작업 시간이 비슷하고, 순서가 중요한 배치 작업(Batch Processing)
    - 은행 창구 대기 줄, 프린터 출력 큐 등 **공정성 & 순서 보장**이 중요한 곳.

---

## 7. 스케줄링 알고리즘 = "프로세스" 전용?

- 아니, 스레드도 스케줄링 함.
- 다만 **프로세스 스케줄링**은 CPU 자원 분배 중심,
    
    **스레드 스케줄링**은 같은 프로세스 내부의 실행 흐름을 분배하는 거라 좀 더 미세 단위.
    

---

## 8. 유저 스레드 vs 커널 스레드 스케줄링

- **유저 스레드:** OS가 직접 모름 → 라이브러리/런타임이 스케줄링.
- **커널 스레드:** OS 커널이 직접 스케줄링.
- 결과적으로 **알고리즘이 다를 수 있음**. 예를 들어, 유저 스레드 라이브러리는 RR 기반, 커널은 MLFQ 기반일 수 있음.

# 면접 대답

## 1. 프로세스 스케줄링 알고리즘 종류

> "대표적으로 FCFS, SJF/SRTF, RR, Priority, MLFQ 등이 있습니다.
FCFS는 단순하지만 Convoy Effect가 있고, SJF는 평균 대기 시간을 최소화하지만 CPU Burst 예측이 어렵습니다.
RR은 공정성을 확보하지만 Time Slice 설정이 중요하고, Priority는 기아 문제가 있습니다.
MLFQ는 여러 큐를 통해 응답성과 공정성을 모두 확보할 수 있습니다."
> 

---

## 2. RR에서 Time Slice Trade-off

> "Time Slice가 짧으면 응답성은 좋아지지만 Context Switching 오버헤드가 증가하고,
길면 오버헤드는 줄지만 사실상 FCFS처럼 응답성이 떨어집니다.
그래서 적정 Time Slice를 설정하는 것이 핵심입니다."
> 

---

## 3. 싱글 스레드 CPU에서 상시로 돌아야 하는 프로세스

> "실시간성이 필요한 경우가 많으므로 Priority Scheduling 또는 실시간 스케줄러(Rate Monotonic, EDF)를 사용합니다.
우선순위를 높여 항상 CPU를 먼저 점유하도록 보장하는 것이 지연을 최소화합니다."
> 

---

## 4. 동시성과 병렬성 차이

> "동시성은 한 CPU에서 시분할로 여러 작업을 번갈아 실행하는 것이고,
병렬성은 여러 CPU 코어에서 물리적으로 동시에 실행하는 것입니다."
> 

---

## 5. MLFQ가 해결하는 문제점

> "MLFQ는 CPU Burst 예측이 어려운 SJF의 단점을 보완하고,
Priority Scheduling의 기아 문제를 Aging으로 해결합니다.
또한 I/O-bound 작업에는 높은 응답성을, CPU-bound 작업에는 공정성을 제공합니다."
> 

---

## 6. FIFO 스케줄러 활용 시나리오

> "작업 시간이 비슷하고 순서 보장이 중요한 배치 작업에 적합합니다.
예를 들어 프린터 큐, 은행 대기열처럼 공정성과 순서가 핵심인 환경에서 효과적입니다."
> 

---

## 7. 스레드 스케줄링 여부

> "스레드도 스케줄링합니다.
프로세스 스케줄링은 CPU 자원을 프로세스 단위로,
스레드 스케줄링은 같은 프로세스 내에서 실행 흐름을 배분하는 방식입니다."
> 

---

## 8. 유저 스레드 vs 커널 스레드 스케줄링

> "유저 스레드는 라이브러리/런타임이 스케줄링하고,
커널 스레드는 OS 커널이 스케줄링합니다.
따라서 알고리즘이 다를 수 있고, 예를 들어 유저 스레드는 RR 기반, 커널은 MLFQ 기반일 수 있습니다."
>
