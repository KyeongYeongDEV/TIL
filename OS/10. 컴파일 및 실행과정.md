## **1. 프로그램이 컴파일되어 실행되는 과정**

1. **소스 코드 작성** → `.c`, `.java`, `.py` 등.
2. **컴파일(Compiler)**
    - 고급 언어 → 어셈블리/머신 코드로 변환.
    - 전처리(Preprocessing) → 컴파일 → 어셈블 → 오브젝트 파일 생성.
3. **링킹(Linking)**
    - 여러 오브젝트 파일과 라이브러리를 묶어서 실행 파일 생성.
4. **로딩(Loading)**
    - 실행 시점에 OS 로더가 실행 파일을 메모리에 적재.
5. **실행(Execution)**
    - CPU가 프로그램 카운터(PC)에 따라 명령어를 하나씩 실행.

---

## **2. 링커(Linker)와 로더(Loader)의 차이**

- **링커**
    - **컴파일 후** 실행 파일 생성 단계에서 동작.
    - 여러 오브젝트 파일·라이브러리 결합, 심볼 해석, 주소 할당.
- **로더**
    - **실행 시점**에 동작.
    - 실행 파일을 메모리에 올리고, 필요한 동적 라이브러리를 로드, 초기화 코드 실행.

---

## **3. 컴파일 언어 vs 인터프리터 언어**

- **컴파일 언어**: 실행 전에 전체 코드를 머신 코드로 변환. (예: C, C++)
    
    → 실행 속도 빠름, 하지만 컴파일 시간 소요.
    
- **인터프리터 언어**: 실행 시 한 줄씩 해석·실행. (예: Python, Ruby)
    
    → 개발 편의성↑, 실행 속도↓.
    
- 실제로는 **혼합형(JIT)**도 많음 (Java, JavaScript).

---

## **4. JIT(Just-In-Time Compilation)**

- 프로그램 실행 중 필요한 시점에 **바이트코드 → 머신 코드** 변환.
- 인터프리터의 유연성과 컴파일 언어의 성능을 결합.
- 예: JVM HotSpot, V8 엔진.

---

## **5. 본인이 사용하는 언어의 컴파일·실행 방식**

- 예: **Java**
    - `.java` → (javac) → `.class`(바이트코드)
    - JVM이 바이트코드 로드 → JIT 컴파일로 네이티브 코드 변환 후 실행.
- 예: **Python (CPython)**
    - `.py` → 바이트코드(`.pyc`) 생성 → Python VM이 해석 실행.

---

## **6. Python 구현체 차이**

- **CPython**: C로 구현된 표준 Python. 바이트코드 해석 방식.
- **Jython**: Java로 구현 → JVM에서 실행 (Java 라이브러리 사용 가능).
- **PyPy**: JIT 컴파일러 내장, CPython보다 속도 빠른 경우 많음.
- 실행 과정 차이:
    - CPython: Python 소스 → CPython 바이트코드 → Python VM 실행.
    - Jython: Python 소스 → JVM 바이트코드 → JVM에서 JIT 실행.
    - PyPy: Python 소스 → 바이트코드 → JIT 컴파일 → 실행.

---

## **7. fork(), exec()와 로더의 관계**

- **fork()**: 현재 프로세스를 복제 (자식 프로세스 생성).
- **exec()**: 현재 프로세스 메모리 공간을 새로운 프로그램으로 교체.
- **로더**는 exec() 호출 시 동작해, 실행 파일을 메모리에 적재하고 실행 환경 초기화.
- 즉, **exec()는 로더를 호출하는 트리거** 역할.

---

```

소스 코드 → 컴파일(Compiler) → 오브젝트 파일
           → 링킹(Linker) → 실행 파일
           → 로딩(Loader) → 메모리 적재 → 실행

```

# 면접 대답

## **1. 프로그램이 컴파일되어 실행되는 과정**

> "소스 코드는 컴파일러를 거쳐 오브젝트 파일이 되고, 링커가 여러 오브젝트 파일과 라이브러리를 묶어 실행 파일을 만듭니다.
실행 시 로더가 이 파일을 메모리에 적재하고, CPU가 명령어를 실행합니다."
> 

---

## **2. 링커와 로더 차이**

> "링커는 컴파일 후 여러 오브젝트 파일과 라이브러리를 결합해 실행 파일을 만들고,
로더는 실행 시 실행 파일을 메모리에 적재하고 필요한 라이브러리를 불러옵니다."
> 

---

## **3. 컴파일 언어와 인터프리터 언어 차이**

> "컴파일 언어는 실행 전 전체를 머신 코드로 변환해 실행 속도가 빠르고,
인터프리터 언어는 실행 시 한 줄씩 해석해 개발 편의성은 높지만 속도는 느립니다."
> 

---

## **4. JIT**

> "JIT은 실행 중 필요한 시점에 바이트코드를 머신 코드로 변환하는 방식으로,
인터프리터의 유연성과 컴파일 언어의 성능을 결합합니다."
> 

---

## **5. 내가 사용하는 언어의 컴파일·실행 방식** *(예: Java)*

> "Java는 javac으로 바이트코드로 컴파일한 뒤 JVM이 로드하고,
JIT 컴파일러가 네이티브 코드로 변환해 실행합니다."
> 

---

## **6. Python 구현체 차이**

> "CPython은 C로 구현된 표준 인터프리터, Jython은 Java 기반으로 JVM에서 실행,
PyPy는 JIT을 내장해 성능이 더 빠른 경우가 많습니다. 실행 과정은 구현체에 따라 바이트코드 변환과 실행 환경이 다릅니다."
> 

---

## **7. fork(), exec()와 로더 관계**

> "exec() 시스템 콜이 호출되면 로더가 실행 파일을 메모리에 적재하고 실행 환경을 초기화합니다.
즉, exec()는 로더를 트리거하는 역할을 합니다."
>
