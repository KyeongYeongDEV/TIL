# 1) Thread Pool / Monitor / Fork-Join

**Thread Pool**

- 미리 생성해 둔 스레드 묶음으로 작업(Tasks)을 큐에 넣고 재사용해서 실행.
- 장점: 스레드 생성/소멸 오버헤드↓, 스케줄링/리소스 제어 쉬움(동시 실행 개수 캡).
- 핵심 요소: 작업 큐(BlockingQueue), 풀 크기, 거부 정책, 타임아웃.

**Monitor**

- “상호배제(Mutex) + 조건변수(Condition)”를 패키징한 동기화 구조.
- 임계구역은 한 번에 한 스레드만, 조건 미충족 시 조건변수에 `wait()`로 잠들고, 다른 스레드가 `notify/signal`로 깨움.
- Java `synchronized + wait/notify`, C# `lock + Monitor`, POSIX `mutex + condvar`가 전형.

**Fork-Join**

- 작업을 재귀적으로 분할(Fork)→ 충분히 작아지면 처리 → 결과를 합침(Join).
- 보통 **워크-스틸링(work-stealing)** 런타임과 붙어서 유휴 스레드가 다른 큐의 일을 훔쳐 오며 부하 분산.
- 대표: Java `ForkJoinPool`, C++ TBB, OpenMP task. 분할정복(정렬/행렬/트리)에서 체감 좋음.

---

# 2) Thread Pool 크기, 어떻게 정하냐?

**기본 공식(감 잡는 용)**

- **CPU-bound**: `N_threads ≈ N_cores` (또는 하이퍼스레딩 고려해 HW threads 근처)
- **I/O-bound**: `N_threads ≈ N_cores × (1 + (WaitTime / ServiceTime))`
    
    = `N_cores / (1 - B)` (B=차단 비율). 대기 비율 높을수록 풀을 더 키움.
    

**실전 가이드**

- 블로킹 많다(네트워크/디스크): **cached/elastic** 풀 or 큰 fixed 풀 + 백프레셔(큐 길이 제한).
- CPU 작업 위주: **작은 fixed** 풀(코어 수 정도) + 작업을 쪼개서 캐시 친화적으로.
- 혼합 워크로드: **작업 분리**(I/O용 풀, CPU용 풀 따로) → 상호 간 섭식 방지.
- 안전장치: 큐 최대 길이, 타임아웃, 거부 정책(CallerRuns 등), 모니터링(Metrics)로 튜닝.

---

# 3) “데이터 정렬” 전략: 안전 + 성능 둘 다 잡으려면?

먼저 요구사항부터 체크:

- **안정성(Stable)** 필요한가? (동키 비교 시 원래 순서 유지)
- **최악 시간 보장** 필요한가? (O(n log n) 보장 vs 평균만 빠름)
- **부분 정렬/거의 정렬** 데이터인가?
- **데이터 크기**(메모리 내 정렬 vs 외부정렬), **병렬화** 가능한가?

**권장 선택지(상황별 베스트 프랙티스)**

- **일반 목적, 안정성 불필요, 최악 보장 원함** → **Introsort**
    
    (퀵정렬 기반 + 깊이 한계 시 힙정렬로 폴백, C++ `std::sort`)
    
    → 평균 빠르고 **최악 O(n log n) 보장**. 안전+성능 밸런스 굿.
    
- **안정성 필요** 또는 **부분 정렬 데이터** → **Timsort**
    
    (Python 리스트, Java 객체 정렬에 채택)
    
    → 실무 데이터에서 **매우 안정적이고 빠름**, 안정성 보장.
    
- **원시 타입 대량(메모리 내)** → **Dual-pivot QuickSort**(Java primitive) 또는 **Introsort**
    
    → 평균 성능 우수, 라이브러리 기본 구현 믿으면 됨.
    
- **멀티코어 적극 활용** → **병렬 정렬**
    - Java: `Arrays.parallelSort`(Fork-Join 기반)
    - C++: 병렬 정책(`std::sort(std::execution::par, ...)`)
    - 병렬 머지/퀵 with 워크-스틸링. **쓰레시홀드**(작아지면 단일스레드) 꼭 넣기.
- **메모리 초과(아주 큼)** → **외부 병합 정렬(External Merge Sort)**
    - 청크 단위로 디스크 정렬 → k-way 머지. 안정성 원하면 머지도 안정적으로.

**실전 한 줄 요약**

- “**안정성 필요 or 거의 정렬** = Timsort / **그 외 일반 목적** = Introsort / **코어 많다** = 라이브러리 **parallel sort** / **메모리 못 담음** = 외부 머지.”

# 면접 대답

## 1) Thread Pool / Monitor / Fork-Join

**Q. Thread Pool이란 무엇인가요?**

> “미리 만들어 둔 스레드 묶음을 재사용해서 작업 큐에 들어온 태스크를 실행하는 구조입니다. 스레드 생성/소멸 오버헤드를 줄이고, 동시 실행 개수를 제어할 수 있어 리소스 관리가 쉽습니다.”
> 

**Q. Monitor란 무엇인가요?**

> “상호 배제와 조건 변수를 패키징한 동기화 구조입니다. 한 번에 한 스레드만 임계 구역에 들어갈 수 있고, 조건이 충족되지 않으면 wait 상태로 대기하다가 다른 스레드의 notify로 깨어납니다.”
> 

**Q. Fork-Join 패러다임은 무엇인가요?**

> “작업을 재귀적으로 분할해서 충분히 작아지면 실행하고, 결과를 합치는 방식입니다. Fork-Join Pool은 워크 스틸링을 지원해 유휴 스레드가 다른 큐의 작업을 가져와 부하를 분산합니다.”
> 

---

## 2) Thread Pool 크기 결정

**Q. Thread Pool 크기는 어떻게 정하나요?**

> “CPU 연산 위주라면 스레드 수를 코어 수와 비슷하게 잡습니다. I/O 대기가 많다면 코어 수에 (1 + 대기시간/서비스시간)을 곱해서 풀을 더 크게 잡습니다. 실무에서는 CPU와 I/O 풀을 분리하고, 큐 길이·타임아웃·거부 정책으로 안정성을 확보합니다.”
> 

---

## 3) 데이터 정렬 전략

**Q. 안정성과 성능을 동시에 고려할 때 어떤 정렬 알고리즘을 선택하시겠습니까?**

> “안정성이 필요하면 Timsort, 안정성이 불필요하고 최악 시간 보장이 필요하면 Introsort를 씁니다. 원시 타입 대량 데이터는 Dual-pivot QuickSort, 멀티코어 환경에서는 Parallel Sort, 메모리에 다 안 담기는 경우엔 외부 병합 정렬을 선택합니다.”
> 

---

## 꼬리질문

**Q. 왜 Timsort가 실무 데이터에서 빠른가요?**

> “실제 데이터는 완전 랜덤이 아니라 부분 정렬된 구간이 많습니다. Timsort는 이 run을 인식하고 효율적으로 병합하기 때문에 평균적으로 더 빠릅니다.”
> 

**Q. Introsort가 최악 O(n log n)을 보장하는 이유는?**

> “QuickSort로 시작하되 분할이 불균형해지면 자동으로 힙정렬로 전환하기 때문에 최악의 경우에도 O(n log n)을 보장합니다.”
>
