# Redis란?

Redis란 key-value 구조의 비정형 데이터를 저장하고 관리하기 위한 비관계형 데이터베이스 관리 시스템이다.

데이터베이스, 캐시, 메세지 브로커로 사용되며 인메모리 데이터 구조를 가진 저장소이다.
오픈소스로써 NoSQL로 분류되기도 한다.

또 Redis는 Remote Dictionary Server의 약자로써 외부에서 사용 가능한 key-value 쌍의 해시 맵 형태의 서버라고 생각할 수 있다.
따라서 **별도의 쿼리문 작성 없이 key값으로 빠르게 결과를 가려올 수 있다.**

# Cache, Memoty Hierarchy

우선 Redis는 In-memory Database로써 캐시 영역에 존재하는 데이터베이스이다.

## Memory Hierarchy

아래 게층 구조를 보면 각 계층의 메모리는 위로 갈수록 빠르고 비싸며, 아래로 갈수록 느려지고 저렴한 메모리 저장소라는 특징이 있다.

- Main Memory(DRAM) : 비교적 빠르고 적당한 크기 + 휘발성
- Disk(SSD, HDD) : 비교적 느리고 엄청 큰 크기 + 비휘발성

![image.png](Redis%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2023f81d8a13f0801e8222c5d438b1c9ae/image.png)

## Cache (In-memory Database)

일반적으로 데이터베이스는 컴퓨터의 전원이 꺼져도 데이터를 저장해야 함으로 디스크에 데이터를 저장한다.
즉, 데이터베이스의 데이터에 접근을 하려면 비교적 느리다.

이때 데이터베이스보다는 **더 자주 접근하고 잘 바뀌지 않는 데이터**를 Memory 상에 저장해서 빠르고 쉽게 접근하자는 취지로 나온 것이 `In-Memory Database(Cache)`인 `Redis`이다.

---

# Redis의 필요성

```cpp
private final Map<String, Object> redis = new HashMap<>();
```

자바에서 이런 HashMap을 데이터베이스로 사용해서 저장해도 memory 데이터베이스이지 않을까요?
따라서 Redis가 아닌 자바의 HashMap을 사용해도 되지 않나라는 생각이 들 수 있다.

그러나 자바를 데이터베이스로 선택했을 때 아래와 같은 문제들이 있다.

## 1. Consistency (일관성) 문제

![image.png](Redis%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2023f81d8a13f0801e8222c5d438b1c9ae/image%201.png)

자바 HashMap을 사용시, 서버가 여러 대인 경우 각 HashMap 각자 다른 데이터를 보유하고 있기 때문에 Consistency 문제가 발생한다.
실제로 Session 같은 것들을 이렇게 자바의 객체로 저장한다면 다른 서버에서는 해당 세션이 없으므로 문제가 발생할 수 있다.

## 2. Race Condition 문제

멀티 스레드 환경에서 `Race Condition` 문제가 발생할 수 있다.

특정 코드 묶음이 있다고 가정하고 그 묶음에는 `Write` 연산을 해야 하는 명령어가 여러 개 존재하는데, 그 코드를 어떤 프로세스나 쓰레드가 실행하는가에 따라 결과가 달라지는 상황을 `Race`라고 한다.

여러 개의 스레드가 경합하면서 `Context Switching`이 주기적으로 발생하다보면 원치 않은 결과가 발생하는 것이다.

### Race 더 자세히..

![image.png](Redis%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2023f81d8a13f0801e8222c5d438b1c9ae/image%202.png)

예를들어 위와 같은 멀티 스레드 환경이 있다고 가정하자
멀티 스레드 환경에서는 모든 스레드들이 같은 코드를 공유하는 상황이다.
그런데 위와 같은 for문을 실행할 경우 우리가 원하는 count 변수의 결과 값은 6000으로 변하길 원하나
막상 실제 결과값은 6000이 안 될 수 있다는 것이다.

count라는 것이 `지역 변수`라면 모든 스레드들이 함께 공유하는 변수가 된다.
따라서 어떤 한 스레드가 count값에 대해서 `write연산 (count++)` 연산을 하고 있는 도중에 
다른 스레드들도 **동시에 write** 하려고 하는 상황이 발생한다면
정상적으로 count 변수에 대해 `write` 연산이 **반영되지 않는 것이다.**

다른 예를 들면
현재 count 값이 2000인 상황이라면
`Thread1`이 count++`연산(write)`을 진행하고 `저장(save)`을 하기 전에
`Thread2`가 count++ `연산`을 진행해 버린다면 `2001`이 아닌
`2000`이라는 값에 대해서 또 연산을 진행해버리는 상황이 발행해버리는 것이다.
즉, 저장을 아직 못 해서 count 변수가 **아직 값이 1이 증가하지 못한 상황에서
1 증가 연산을 또 다른 스레드가 하려고 하니 결과값이 비정상적**으로 도출이 되는 것이다.

---

# 싱글 스레드, Critical Section 동기화 환경 제공

![image.png](Redis%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2023f81d8a13f0801e8222c5d438b1c9ae/image%203.png)

위와 같은 Race 상황을 방지하도록 Redis는 `싱글 스레드` 환경에 기반하여 동작한다.
또 Redis의 자료구조는 `Cirtical Section이라는 영역에 대해 동기화 (Syncronization)환경 제공` 한다.

## Critical Section이란?

동시에 여러 프로세스가 접근하면 안 되는 영역이다.
여러 Read, Write 연산들에 대한 **동기화**를 시켜줌으로써 Race와 같은 **원치 않은 결과를 막아주도록** Redis의 자료구조가 구현되어 있다.

---

# Redis를 언제 사용할까?

세션과 같은 **여러 서버에서 같은 데이터를 공유해야 하는 상황**에서 사용하면 된다.
또한 단일 서버더라도 **캐시의 기능으로 빠른 연산 및 접근이 가능하도록 사용**할 수도 있다.

# Redis 주의점

![image.png](Redis%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2023f81d8a13f0801e8222c5d438b1c9ae/image%204.png)

- Redis는 Single Thread 서버 환경에서 동작함으로 반드시 시간복잡도를 고려해서 사용해야 한다.

## 1. O(n) 시간 복잡도가 걸리는 상황

만일 Redis에서 제공하는 기능중에서 특정 데이터를 찾는 연산을 사용한다고 해보자.
그렇다면 처음부터 차례대로 모든 원소들을 다 찾아봐야 할 텐데, 이 경우 최악으로 O(n)이 나온다.
1천만 개의 데이터가 있다고 가정하면 1천만 개에 대해 모두 연산을 해야 하기 때문에 시간이 오래 걸린다.

대표적으로 `모든 key`를 가져오는 연산이나 `Flush`, `GetAll` 과 같은 명령어들이 이에 해당한다.
모든 데이터를 다루는 연산이므로 사용에 주의해야 한다.

## 2. 서버가 다운되는 상황

Redis는 싱글 스레드로 동작하기 때문에 하나의 클라이언트가 KEYS *와 같이 느린 명령어를 실행하면, 해당 작업이 끝날 때까지 다른 모든 클라이언트의 요청이 대기하게 된다.
예를들어 A가 1천만 개의 키를 조회하느라 10초를 소모하면 B와 C의 간단한 GET, SET 요청도 그동안 응답을 받지 못하고 지연되며, 이로 인해 사용자 입장에서는 Redis가 **마치 죽은 것처럼 느끼**게 된다.
이런 **상황이 반복되면 `timeout`이나 연결 끊김이 발생하고, 실제로 다운된 것이 아님에도 장애로 오인**될 수 있다.

이러한 현상은 Redis의 멀티 태스킹 불가능 구조와 블로킹 명령어 처리 특성에 기인하며
흔히 `싱글스레드 병목` 또는 `블로킹 리스크`라고 불린다.

## 3. Memory Fregmentation

Redis를 사용할 시 **메모리 단편화(Memory Fragmentation) 문제를 고려해서 메모리를 적당히 여유롭게 사용**하는 것이 좋다.

Memory Fragmentation에는 크게 `Internal Fragmentation`, `External Fragmentation` 으로 나누어진다.

### 3.1 External Fragmentation

![image.png](Redis%20%E1%84%82%E1%85%A2%E1%84%87%E1%85%AE%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%2023f81d8a13f0801e8222c5d438b1c9ae/image%205.png)

External Fragmentation(외부 단편화)은 메모리 공간에 여유가 있음에도 불구하고 연속되지 않은 작은 빈 공간들로 인해 큰 데이터를 수용하지 못하는 현상이다. 
예를 들어, 여러 블록이 비워져 있어 총 용량은 충분하지만 그 사이에 적절한 크기의 연속 공간이 없어 새로운 데이터를 넣지 못하는 경우가 발생한다. 
이로 인해 실제로는 사용 가능한 메모리가 존재함에도 시스템은 더 많은 메모리를 필요로 한다고 판단하게 되고,
그 결과 **실제 사용량보다 과도한 메모리를 요구하거나** **프로세스가 죽는 현상**이 발생할 수 있다. 
이는 메모리 효율성 저하와 함께 시스템 안정성에도 영향을 미치는 중요한 이슈다.

### 3.2 Internal Fragmentation

Internal Fragmentation(내부 단편화)는 메모리 블록을 할당할 때, 실제 필요한 메모리보다 더 큰 고정 크기의 블록을 할당하면서 **남는 공간이 낭비되는 현상**을 말한다. 
예를 들어, 32KB 단위로 메모리를 할당하는 시스템에서 어떤 프로세스가 25KB만 필요하다면
나머지 7KB는 사용되지 않고 낭비된다. 이처럼 할당된 블록 내부에 존재하지만 실제로는 사용되지 않는 공간이 누적되면 전체 메모리의 효율성이 크게 저하될 수 있다. 
내부 단편화는 주로 **고정 분할(Fixed Partitioning)** 방식에서 발생하며, 메모리 관리 전략을 잘못 설계할 경우 시스템 자원을 낭비하게 되는 원인이 된다.

## 4. Replication : Forking

Replication 방식은 Redis가 **휘발성(In-memory) 데이터 저장소**이기 때문에, 데이터 유실 위험을 줄이기 위해 사용하는 **데이터 복제 방식**이다. 
Redis는 `서버 프로세스`(Redis-Server)에서 `자식 프로세스`(Child Process)를 생성해 메모리 내용을 복사(Forking)하고, 이를 디스크 등에 저장함으로써 데이터를 `영속화`한다. 
그러나 이 과정은 전체 메모리를 한 번 더 사용하는 구조이므로, 메모리 여유가 충분하지 않다면 **복제 과정에서 메모리 부족으로 인해 서버가 다운되는 현상**이 발생할 수 있다. 
따라서 Forking 기반의 복제 연산을 사용할 때는 **충분한 메모리 확보가 필수적**이다.

# Reference

[https://velog.io/@msung99/Redis-CS-관련-지식부터-뜯어보며-이해하는-Redis-내부-구조와-메커니즘을-살펴보자](https://velog.io/@msung99/Redis-CS-%EA%B4%80%EB%A0%A8-%EC%A7%80%EC%8B%9D%EB%B6%80%ED%84%B0-%EB%9C%AF%EC%96%B4%EB%B3%B4%EB%A9%B0-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-Redis-%EB%82%B4%EB%B6%80-%EA%B5%AC%EC%A1%B0%EC%99%80-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98%EC%9D%84-%EC%82%B4%ED%8E%B4%EB%B3%B4%EC%9E%90)
